# BFS를 활용한 그리드 탐색 문제 (백준 문제 1926)

## 문제 설명
2차원 그리드에서 BFS(너비 우선 탐색) 알고리즘을 사용하여 특정 조건을 만족하는 영역의 개수와 가장 큰 영역의 크기를 찾는 문제입니다. 
각 영역은 상하좌우로 인접한 1들로 구성되며, 이 문제의 목표는 전체 그리드에서 영역의 개수를 찾고 가장 큰 영역의 크기를 계산하는 것입니다.

## 입력 형식
- 첫 번째 줄에는 그리드의 행(`n`)과 열(`m`)의 크기가 주어집니다.
- 다음 `n`개의 줄에 걸쳐서 각 행의 그리드 상태가 주어집니다. 1은 영역을, 0은 빈 공간을 나타냅니다.

## 출력 형식
- 첫 번째 줄에는 전체 그리드에서 찾은 영역의 개수를 출력합니다.
- 두 번째 줄에는 가장 큰 영역의 크기를 출력합니다.

## 예제 입력
```
6 5
1 1 0 1 1
0 1 1 0 0
0 0 0 0 0
1 0 1 1 1
0 0 1 1 1
0 0 1 1 1
```

## 예제 출력
```
4
9
```

## 해결 방법
BFS를 사용하여 각 1이 나타내는 영역을 탐색하고, 연결된 모든 1들을 방문 처리하여 영역의 크기를 계산합니다. 
모든 그리드를 탐색하여 영역의 개수와 가장 큰 영역의 크기를 찾습니다.

## 구현 코드
```java
import java.util.Scanner;
import java.io.IOException;

public class Main {
    static final int MAX_N = 101;
    static int[] dy = {-1, 0, 1, 0};
    static int[] dx = {0, 1, 0, -1};
    static int n, m, ans = 1;
    static int[][] a = new int[MAX_N][MAX_N];
    static boolean[][] visited = new boolean[MAX_N][MAX_N];

    static void dfs(int y, int x, int d) {
        visited[y][x] = true;
        for (int i = 0; i < 4; i++) {
            int ny = dy[i] + y;
            int nx = dx[i] + x;
            if (ny < 0 || ny >= n || nx < 0 || nx >= n) continue;
            if (a[ny][nx] > d && !visited[ny][nx]) {
                dfs(ny, nx, d);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = sc.nextInt();
            }
        }
        for (int d = 1; d < 101; d++) {
            int cnt = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    visited[i][j] = false;
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (a[i][j] > d && !visited[i][j]) {
                        cnt++;
                        dfs(i, j, d);
                    }
                }
            }
            ans = Math.max(ans, cnt);
        }
        System.out.println(ans);

        sc.close();
    }
}
```

## 시간 복잡도
이 알고리즘의 시간 복잡도는 <b>O(n*m)</b>입니다. 그리드의 모든 셀을 한 번씩 검사하므로, 행의 수(n)와 열의 수(m)를 곱한 값에 비례하는 연산이 필요합니다.

## 공간 복잡도
공간 복잡도는 <b>O(n*m)</b>입니다. 주어진 그리드의 크기와 같은 방문 배열을 유지해야 하므로, 그리드의 크기에 비례하는 추가 메모리가 필요합니다.

## 문제 링크
- [Baekjoon Online Judge 문제 1926](https://www.acmicpc.net/problem/1926)